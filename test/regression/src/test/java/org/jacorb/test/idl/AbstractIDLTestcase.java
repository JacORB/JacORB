/*
 *        JacORB - a free Java ORB
 *
 *   Copyright (C) 1999-2012 Gerald Brose / The JacORB Team.
 *
 *   This library is free software; you can redistribute it and/or
 *   modify it under the terms of the GNU Library General Public
 *   License as published by the Free Software Foundation; either
 *   version 2 of the License, or (at your option) any later version.
 *
 *   This library is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *   Library General Public License for more details.
 *
 *   You should have received a copy of the GNU Library General Public
 *   License along with this library; if not, write to the Free
 *   Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 */

package org.jacorb.test.idl;

import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import java.io.File;
import java.io.IOException;
import java.io.StringWriter;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import junit.framework.AssertionFailedError;
import org.jacorb.test.common.ORBTestCase;
import org.jacorb.test.common.TestUtils;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;

@RunWith(value = Parameterized.class)
public class AbstractIDLTestcase extends ORBTestCase
{
    protected final File idlFile;

    /**
     * dir where the idl compiler places generated
     * java source files.
     */
    protected final File dirGeneration;

    /**
     * dir where .class are compiled to.
     */
    protected final File dirCompilation;

    public AbstractIDLTestcase(File file)
    {
        assertTrue(file + " should exist", file.exists());
        assertTrue(file.isFile());

        idlFile = file;

        dirGeneration = new File(TestUtils.testHome() + "/src-testidl/" + idlFile.getName());
        TestUtils.deleteRecursively(dirGeneration);
        File dirClasses = new File(TestUtils.testHome() + "/classes-testidl");

        dirClasses.mkdir();
        assertTrue(dirClasses.canWrite());
        assertTrue(dirClasses.isDirectory());

        dirCompilation = new File(dirClasses, idlFile.getName());
        TestUtils.deleteRecursively(dirCompilation);
    }

    /**
     * run JacORBs IDL compiler on the current idlFile
     */
    protected void runJacIDL(boolean failureExpected) throws Exception
    {
        final String details;

        details = runJacIDLInProcess(failureExpected);

        TestUtils.log("[" + idlFile.getName() + " output]:\n" + details);
    }

    private String runJacIDLInProcess(boolean failureExpected) throws AssertionFailedError
    {
        String[] file = createJacIDLArgs();

        dirGeneration.mkdir();

        StringWriter writer = new StringWriter();
        final String details = writer.toString();
        try
        {
            boolean success = org.jacorb.idl.parser.compile(file, writer);

            assertTrue("parser didn't succeed", success);

            if (failureExpected)
            {
                fail("parsing of " + idlFile.getName() + " should fail.");
            }
        }
        catch (Exception e)
        {
            handleJacIDLFailed(failureExpected, details, e);
        }

        return details;
    }

    private void handleJacIDLFailed(boolean failureExpected, final String details, Exception e) throws AssertionFailedError
    {
        if (!failureExpected)
        {
            AssertionFailedError error = new AssertionFailedError("parsing of " + idlFile.getName()
                    + " failed: " + details);
            error.initCause(e);
            throw error;
        }
    }

    /**
     * compile all .java files that were
     * generated by a previous IDL run.
     * this method depends on a properly configured
     * environment that has javac available.
     * @return a ClassLoader that can be used to access the compiled classes
     */
    protected ClassLoader compileGeneratedSources(boolean failureExpected) throws IOException
    {
        File[] files = getJavaFiles();
        return TestUtils.compileJavaFiles(this.dirCompilation, files, failureExpected);
    }

    /**
     * get a list of all .java files that were
     * generated by a previous IDL run.
     */
    protected File[] getJavaFiles()
    {
        return TestUtils.getJavaFilesRecursively(dirGeneration).toArray(new File[0]);
    }

    /**
     * build the argument list that will be used to invoke the
     * IDL compiler.
     */
    protected String[] createJacIDLArgs()
    {
        String file[] = new String[] { "-forceOverwrite", "-d", dirGeneration.getAbsolutePath(),
                idlFile.getAbsolutePath() };
        return file;
    }

    /**
     * search for a method with the signature
     * public void verify_<FILENAME>(ClassLoader cl) {...}
     * (dots in filename will be converted to _) and invoke
     * it with the specified classloader.
     */
    protected void invokeVerifyMethod(ClassLoader cl) throws IllegalAccessException, InvocationTargetException
    {
        try
        {
            // test if a verify_ method is available and invoke it
            String file = idlFile.getName().replaceAll("\\.", "_");

            TestUtils.log("look for verify_" +  file);

            Method method = getClass().getMethod("verify_" + file, new Class[] {ClassLoader.class});
            method.invoke(this, new Object[] {cl});
        }
        catch (NoSuchMethodException e)
        {
            // ignored
        }
    }
}
