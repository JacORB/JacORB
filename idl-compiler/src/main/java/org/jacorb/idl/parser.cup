package org.jacorb.idl;

/*
 *        JacORB - a free Java ORB
 *
 *   Copyright (C) 1997-2012 Gerald Brose / The JacORB Team.
 *
 *   This library is free software; you can redistribute it and/or
 *   modify it under the terms of the GNU Library General Public
 *   License as published by the Free Software Foundation; either
 *   version 2 of the License, or (at your option) any later version.
 *
 *   This library is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *   Library General Public License for more details.
 *
 *   You should have received a copy of the GNU Library General Public
 *   License along with this library; if not, write to the Free
 *   Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.io.Writer;
import java.net.URL;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Stack;
import java.util.Vector;
import java.util.jar.Manifest;
import java.util.logging.ConsoleHandler;
import java.util.logging.Level;
import java.util.logging.Formatter;
import java.util.logging.Handler;
import java.util.logging.LogRecord;
import java.util.logging.Logger;

/**
 *
 * JavaCup Specification for CORBA IDL, to be processed like this:
 * java java_cup.Main < parser.cup
 *
 * @author Gerald Brose <mailto:gerald.brose@acm.org>
 */

action code
{:
:};


parser code
{:
    static String command_line[] = null;

    public static Hashtable pack_replace = new Hashtable();
    public static Stack scopes = new Stack();
    private static Hashtable tmpDefines = new Hashtable();
    private static Hashtable tmpUnDefines = new Hashtable();

    public final static String currentVersion = "";

    static final String compiler_version = parser.class.getPackage ().getImplementationVersion ();

    private static org.jacorb.idl.IDLTreeVisitor generator = null;

    private static final String FINAL = " final";
    private static final String NO_FINAL = "";

    public static String out_dir = ".";
    static String package_prefix = null;

    static boolean parse_only = false;

    /** used for internal checking that name conversion
        to mapped Java names is done only after parsing */
    public static boolean done_parsing = false;

    /** compiler flags */
    public static boolean include_state = false;
    public static boolean strict_names = true;
    /**
     * <code>strict_identifiers</code> defaults to on and is used to
     * disable case insensitive identifiers - see section 3.2.3 of 04-03-12.
     */
    public static boolean strict_identifiers = true;
    /** these two are to work around buggy IDL generated by Sun's rmic in JDK 1.4 */
    public static boolean strict_inheritance = true;
    public static boolean strict_attributes = true;

    public static boolean generateIR = false;
    public static boolean generate_skeletons = true;
    public static boolean generate_stubs = true;

    public static boolean generate_ami_callback = false;
    public static boolean generate_ami_polling  = false;

    protected static boolean generateIncluded = false;
    protected static boolean inhibitionState = false;
    protected static boolean localityContraint = false;
    protected static boolean useUncheckedNarrow = false;
    protected static boolean cldc10 = false;
    static boolean generateEnhanced;

    public static final int HELPER_DEPRECATED = 0;
    public static final int HELPER_PORTABLE = 1;
    public static final int HELPER_JACORB = 2;

    static int generatedHelperPortability = HELPER_PORTABLE;

    protected static boolean forceOverwrite;
    protected static boolean addbackend = false;

    protected static boolean generateDiiStubs = false;

    protected static String finalString = FINAL;

    private static int activeParseThreads;

    public static Logger logger;
    public static Handler handler;

    /*  a la CORBA 2.4, allow forward declarations that remain undefined */
    public static boolean sloppy = false;

    public static String currentDate = java.text.DateFormat.getDateTimeInstance().format(new java.util.Date());

    private static ObjectCachePlugin objectCachePlugin;

    public static boolean printVersionTimestamps = true;

    /**
     *  allows reinitialization if compiler is not
     *  run from a command-line
     */

    protected static void cleanup()
    {
        GlobalInputStream.cleanUp();
        generatedHelperPortability = HELPER_PORTABLE;
        pending_interfaces.clear();
        pack_replace.clear();
        scopes.clear();
        tmpDefines.clear();
        tmpUnDefines.clear();
        generator = null;
        objectCachePlugin = null;

        activeParseThreads = 0;
        InterfaceBody.clearParseThreads ();

        out_dir = ".";
        package_prefix = null;

        parse_only = false;
        done_parsing = false;

        include_state = false;
        generateIR = false;
        generate_skeletons = true;
        generate_stubs = true;
        generate_ami_callback = false;
        generate_ami_polling = false;

        strict_names = true;
        strict_identifiers = true;
        strict_inheritance = true;
        strict_attributes = true;

        generateIncluded = false;
        inhibitionState = false;
        localityContraint = false;
        useUncheckedNarrow = false;
        cldc10 = false;
        generateEnhanced = false;
        forceOverwrite = false;

        generateDiiStubs = false;

        finalString = FINAL;

        sloppy = false;

   }

    protected static final void initLogging()
    {
        logger = Logger.getLogger("org.jacorb.idl");
        logger.setLevel(Level.SEVERE);

        Formatter formatter = new Formatter() {

            @Override
            public String format(LogRecord arg0) {
                StringBuilder b = new StringBuilder();
                b.append(arg0.getLevel());
                b.append(" ");
                b.append(arg0.getSourceClassName());
                b.append(" ");
                b.append(arg0.getSourceMethodName());
                b.append(" ");
                b.append(arg0.getMessage());
                b.append(System.getProperty("line.separator"));

                Throwable t = arg0.getThrown();
                return t == null ? b.toString() : b.toString () + getStackTrace (t);
            }

            private String getStackTrace (Throwable t)
            {
                StringWriter sw = new StringWriter();
                t.printStackTrace(new PrintWriter (sw));
                return sw.toString();
            }
        };

        handler = new ConsoleHandler();
        handler.setFormatter (formatter);
        handler.setLevel (Level.SEVERE);

        logger.addHandler(parser.handler);
    }


    public static void main( String argv[] )
    {
        initLogging();

        if( compileAndHandle( argv ) == true )
            System.exit( 0 );
        else
            System.exit( 1 );
    }


    public static boolean compileAndHandle( String argv[] )
    {
        try
        {
            return compile( argv );
        }
        catch( org.jacorb.idl.ParseException e )
        {
            parser.logger.log(Level.ALL, "Exception caught", e);
            lexer.emit_error( e.getMessage() );
            return false;
        }
        catch ( java.io.IOException io )
        {
            lexer.emit_error("IO Error, please check file names: " + io.getMessage());
        }
        catch( Exception e )
        {
            lexer.emit_error( "Exception: " + e.toString() );
            usage( argv, e.getMessage() );
        }
        return false;
    }

    public static boolean compile( String argv[] )
        throws Exception
    {
        BufferedReader in = null;

        if ( logger == null )
        {
            initLogging();
        }

        parser.openScope();

        command_line = argv;
        if( argv.length > 0 )
        {
            int i;
            for( i = 0; i < argv.length; i++ )
            {
                if( argv[i].equals("-syntax"))
                {
                    parse_only = true;
                    continue;
                }
                if( argv[i].equals("-diistub"))
                {
                    generateDiiStubs = true;
                    continue;
                }
                if( argv[i].equals("-noskel"))
                {
                    generate_skeletons = false;
                    continue;
                }
                if( argv[i].equals("-nostub"))
                {
                    generate_stubs = false;
                    continue;
                }
                if( argv[i].equals("-ami_callback"))
                {
                    generate_ami_callback = true;
                    continue;
                }
                if( argv[i].equals("-forceOverwrite"))
                {
                    forceOverwrite = true;
                    continue;
                }
                if( argv[i].equals("-ami_polling"))
                {
                    throw new RuntimeException
                      ("Sorry, the polling model is not yet implemented.");
                    // generate_ami_polling = true;
                    // continue;
                }
                if( argv[i].equals("-sloppy_forward"))
                {
                    sloppy = true;
                    continue;
                }
                if( argv[i].equals("-sloppy_names"))
                {
                    strict_names = false;
                    continue;
                }
                if( argv[i].equals("-sloppy_identifiers"))
                {
                    strict_identifiers = false;
                    continue;
                }
                if( argv[i].equals("-permissive_rmic"))
                {
                    strict_names = false;
                    strict_attributes = false;
                    strict_inheritance = false;
                    continue;
                }
                if( argv[i].equals("-unchecked_narrow"))
                {
                    useUncheckedNarrow = true;
                    continue;
                }
                if( argv[i].equals("-backend") || argv[i].equals("-addbackend"))
                {
                    if (argv[i].equals("-addbackend"))
                    {
                        addbackend = true;
                    }

                    if( i+1 == argv.length || argv[i+1].charAt(0)=='-' )
                        usage(argv, "-backend");

                    // custom code generators
                    Class codeGeneratorClass = null;

                    try
                    {
                        codeGeneratorClass = Class.forName( argv[++i] );
                    }
                    catch( ClassNotFoundException cnfe )
                    {
                        throw new ParseException("Generator Class " + argv[i] + " not found! Check classpath!");
                    }

                    if( ! org.jacorb.idl.IDLTreeVisitor.class.isAssignableFrom( codeGeneratorClass ))
                        throw new ParseException( "Not a valid code generator: " +
                            codeGeneratorClass.getName() );
                    setGenerator( (org.jacorb.idl.IDLTreeVisitor) codeGeneratorClass.newInstance());
                    continue;
                }
                if( argv[i].equals("-cacheplugin"))
                {
                    if( i+1 == argv.length || argv[i+1].charAt(0)=='-' )
                        usage(argv, "-cacheplugin");

                    setObjectCachePlugin(argv[++i]);
                    continue;
                }
                if( argv[i].equals("-d"))
                {
                    if( i+1 == argv.length || argv[i+1].charAt(0)=='-' )
                        usage(argv, "-d");
                    out_dir = argv[++i];
                    continue;
                }
                if( argv[i].equals("-W"))
                {
                    if( i+1 == argv.length || argv[i+1].charAt(0)=='-' )
                        usage(argv, "-W");

                    int level = Integer.parseInt( argv[++i] );

                    logger.setLevel(Environment.intToLevel(level));
                    handler.setLevel(Environment.intToLevel(level));

                    continue;
                }
                if( argv[i].startsWith("-D"))
                {
                    String def = argv[i].substring(2);
                    String val;

                    if( def.indexOf('=') > 0 )
                    {
                        val = def.substring( def.indexOf('=') + 1);
                        def = def.substring( 0, def.indexOf('='));
                    }
                    else
                        val = "1";
                    tmpDefines.put( def, val );
                    continue;
                }
                if( argv[i].startsWith("-U"))
                {
                        tmpUnDefines.put( argv[i].substring(2), "" );
                        continue;
                }
                if( argv[i].equals("-cldc10"))
                {
                        cldc10 = true;
                        continue;
                }
                if( argv[i].equals("-genEnhanced"))
                {
                    generateEnhanced = true;
                    continue;
                }
                if( argv[i].equals("-generate_helper"))
                {
                    String level = argv[++i];

                    generatedHelperPortability = parseGeneratedHelperPortability(level);

                    if (generatedHelperPortability < 0)
                    {
                        usage(argv, "argument to -generate_helper should be one of (portable|jacorb|deprecated)");

                        return false;
                    }

                    continue;
                }
                if( argv[i].equals("-i2jpackage"))
                {
                    if( i+1 == argv.length || argv[i+1].charAt(0)=='-')
                        usage(argv, "-i2jpackage");
                     addI2JPackage (argv[i+1]);
                    i++;
                    continue;
                }
                if (argv[i].equals ("-i2jpackagefile"))
                {
                   if( i+1 == argv.length || argv[i+1].charAt(0)=='-')
                        usage(argv, "-i2jpackagefile");

                       try
                       {
                          in = new BufferedReader (new FileReader (argv[i+1]));
                       }
                       catch (FileNotFoundException e)
                       {
                          System.out.println ("File " + argv[i+1] + " not found");
                          throw new RuntimeException
                             ("File for -i2jpackagefile not found");
                       }
                       String mapping = in.readLine ();
                       while (mapping != null)
                       {
                          addI2JPackage (mapping);
                          mapping = in.readLine ();
                       }
                       in.close ();
                       i++;
                       continue;
                }
                if( argv[i].equals("-ir"))
                {
                        generateIR = true;
                        continue;
                }
                if( argv[i].startsWith("-I"))
                {
                    GlobalInputStream.setIncludePath(argv[i].substring(2));
                    continue;
                }
                if( argv[i].equals("-h") || argv[i].equals("-help") )
                {
                    help();
                    return true;
                }
                if( argv[i].equals("-all") )
                {
                        generateIncluded = true;
                        continue;
                }
                if( argv[i].equals("-v") || argv[i].equals("-version") )
                {
                    version();
                    return true;
                }
                if ( argv[i].equals("-nofinal") )
                {
                    setFinalString(NO_FINAL);
                    continue;
                }
                if( argv[i].equals("-in") )
                {
                    i++;
                    if( i < argv.length )
                    {
                        prepareAndParse(argv[i]);
                    }
                    continue;
                }
                if( argv[i].equals("-notimestamps"))
                {
                    printVersionTimestamps = false;
                    continue;
                }
                if( argv[i].endsWith(".idl") )
                {
                    break;
                }

                // else:
                usage(argv, "Unrecognized option: " + argv[i]);

            }

            try
            {
                for( int j=i; j < argv.length; j++)
                {
                    if( argv[j].endsWith(".idl"))
                    {
                        prepareAndParse(argv[j]);
                    }
                    else
                    {
                        throw new ParseException("Not an IDL file:" + argv[j]);
                    }
                }
            }
            finally
            {
                cleanup();
            }
        }
        return true;
    }

    public static int parseGeneratedHelperPortability(String level)
    {
        if (level.equals("deprecated"))
        {
            return HELPER_DEPRECATED;
        }
        else if (level.equals("portable"))
        {
            return HELPER_PORTABLE;
        }
        else if (level.equals("jacorb"))
        {
            return HELPER_JACORB;
        }
        else
        {
            return -1;
        }
    }

    private static void prepareAndParse(String fileName)
        throws Exception
    {
        GlobalInputStream.init();
        GlobalInputStream.setInput( fileName );

        /* reset tables everywhere */
        lexer.reset();
        NameTable.init();
        ConstDecl.init();
        TypeMap.init();

        /* define/undefine symbols */
        for( Enumeration e = tmpDefines.keys(); e.hasMoreElements(); )
        {
            String key = (String)e.nextElement();
            lexer.define( key, (String)tmpDefines.get( key ));
        }

        /* Standard compiler defines, can be undefined */

        lexer.define("JACORB", "1");
        lexer.define("_PRE_3_0_COMPILER_", "1");
        lexer.define("GIOP_1_1", "1");
        lexer.define("GIOP_1_2", "1");

        for( Enumeration e = tmpUnDefines.keys(); e.hasMoreElements(); )
        {
            lexer.undefine( (String)e.nextElement() );
        }

        new parser().parse();

        if( lexer.error_count > 0 )
        {
            throw new ParseException( "Errors in lexer" );
        }
    }




    public static void usage(String [] argv, String msg)
    {
        // debug:
        for( int i = 0; i < argv.length; i++)
            System.out.print( argv[i] + " " );
        System.out.println(" : " + msg);

        System.out.println("Usage: idl [-h|-help][-v|-version][-Dsymbol[=value]][-Idir][-U<symbol>][-W debug_level ][-all][-forceOverwrite][-ami_callback][-ami_polling][-backend classname][-d <Output Dir>][-unchecked_narrow][-i2jpackage x:y][-i2jpackagefile <filename>][-cldc10][-ir][-nofinal][-noskel][-nostub][-notimestamps][-diistub][-sloppy_forward][-sloppy_names][-sloppy_identifiers][-permissive_rmic][-genEnhanced][-syntax][-in inputfile][-generate_helper (portable|jacorb|deprecated)][-cacheplugin classname] <filelist>");
    }


    static void addI2JPackage( String mapping )
    {
       int split_idx = mapping.indexOf(':');
       if( split_idx  < 0 )
       {
          System.out.println ("Incorrect format for i2jpackage mapping: " + mapping);
          System.exit (1);
       }
       String idlp = mapping.substring(0,split_idx);
       String jp = mapping.substring(split_idx+1);

       if( idlp.length() == 0 )
       {
           package_prefix = jp;
           parser.logger.log(Level.ALL, "Replace unnamed global package with " + jp );
       }
       else
       {
           pack_replace.put( idlp, jp );
           parser.logger.log(Level.ALL, "Replace pack " + idlp + " with " + jp );
       }
    }


    private static void help()
    {
        System.out.println("\t-h|help \tthese few lines of help");
        System.out.println("\t-v|version \tprint version information");
        System.out.println("\t-d dir\t\troot of directory tree for output");
        System.out.println("\t-Dx\t\tdefine preprocessor symbol x with value 1");
        System.out.println("\t-Dx=y\t\tdefine preprocessor symbol x with value y");
        System.out.println("\t-Idir\t\tset include path for idl files");
        System.out.println("\t-U<symbol>\t\tundefine preprocessor symbol");
        System.out.println("\t-W [1..4]\tdebug level");
        System.out.println("\t-all\t\tgenerate code for all IDL files, even included ones");
        System.out.println("\t-forceOverwrite\tgenerate code even if IDL has not changed");
        System.out.println("\t-ami_callback\t\tgenerate AMI reply handlers and sendc methods");
        System.out.println("\t-ami_polling\t\tgenerate AMI poller and sendp methods");
        System.out.println("\t-backend classname\t\tuse classname as code generator");
        System.out.println("\t-addbackend classname\t\tadd classname as code generator");
        System.out.println("\t-i2jpackage x:a.b.c\t replace IDL package name x by a.b.c in generated Java code (e.g. CORBA:org.omg.CORBA)");
        System.out.println("\t-i2jpackagefile <filename>\t replace IDL package names using list from <filename>. Format as above.");
        System.out.println("\t-ir\t\tgenerate information required by the Interface Repository");
        System.out.println("\t-nofinal\tgenerated Java code will contain no final class definitions");
        System.out.println("\t-notimestamps\tgenerated Java code will not have a version timestamp");
        System.out.println("\t-unchecked_narrow\t\tuse unchecked_narrow in generated code for IOR parameters in operations");
        System.out.println("\t-noskel\t\tdisables generation of POA skeletons");
        System.out.println("\t-nostub\t\tdisables generation of client stubs");
        System.out.println("\t-diistub\t\tgenerate dii-based client stubs");
        System.out.println("\t-cldc10\t\tcode generation compatible with J2ME/CLDC 1.0");
        System.out.println("\t-sloppy_forward\tallow forward declarations wo. later definitions");
        System.out.println("\t-sloppy_names\tless strict checking of module name scoping");
        System.out.println("\t-sloppy_identifiers\tAllow certain illegal identifiers.");
        System.out.println("\t-permissive_rmic\ttolerate dubious IDL generated by JDK's rmic, includes -sloppy_names.");
        System.out.println("\t-genEnhanced\tGenerate toString and equals on stubs. Only supported on Struct currently.");
        System.out.println("\t-generate_helper (portable[default]|jacorb|deprecated). Controls the controls the compatibilty level of the generated helper code.");
        System.out.println("\t-cacheplugin classname\tset plugin for cache code generation");

        System.out.println("\t-syntax\t\tsyntax check only, no code generation");
        System.out.println("\t<filelist>\t");
  }

    private static void version()
    {
        String compiler_date = "";
        String sha = "";
        try
        {
            Enumeration<URL> resources = parser.class.getClassLoader().getResources("META-INF/MANIFEST.MF");

            while (resources.hasMoreElements())
            {
                URL idl = resources.nextElement ();
                if (idl.getFile ().contains ("idl.jar"))
                {
                    Manifest manifest = new Manifest (idl.openStream());
                    compiler_date = manifest.getMainAttributes ().getValue ("Build-Timestamp");
                    sha = manifest.getMainAttributes ().getValue ("Scm-Revision");
                    break;
                }
            }
        }
        catch (java.io.IOException e)
        {
            System.err.println ("Error retrieving information from manifest");
            e.printStackTrace ();
        }

        System.out.println
        (
            "JacORB IDL compiler V" + compiler_version + " (" +
            compiler_date + ") (SHA: " + sha + ')' + System.getProperty("line.separator") +
            "\t(C) The JacORB Project " + releaseYear
        );
    }

    /* override error routines */

    public void report_fatal_error( String message, Object info)
        throws ParseException
    {
       done_parsing();
       lexer.emit_error(message + "\nCan't recover from previous error(s), giving up.");
       throw new ParseException();
    }

    public static void fatal_error(String message, str_token p_info)
        throws ParseException
    {
       //done_parsing();
       lexer.emit_error(message + "\nCan't recover from previous error(s), giving up.", p_info);
       throw new ParseException();
    }

    public void report_error(String message, Object info)
    {
       lexer.emit_error(message);
    }

    public static void error(String message, str_token p_info)
    {
       lexer.emit_error(message, p_info);
    }

    public static void error( String message )
    {
       lexer.emit_error( message );
    }

    /* bookkeeping with IDL scopes */

    /** called from the lexer/scanner whenever a scope opening
        symbol is encountered */

    public static void openScope()
    {
        scopes.push(new ScopeData());
    }

    /** called from within the parser whenever parsing a scope
        symbol is complete */

    public static void closeScope(Scope symbol)
    {
            ScopeData data = (ScopeData) scopes.pop();
            symbol.setScopeData( data );
    }

    public static ScopeData currentScopeData()
    {
            return (ScopeData)scopes.peek();
    }


    // an interface inheriting from an forward declared interface
    // needs to wait on an object until the ancestor has been parsed
    // if get_pending returns null, the ancestor was not forward
    // declared and thus has already been parsed

    // forward declared interfaces are put into this list

    static Hashtable pending_interfaces = new Hashtable();

    public static synchronized void set_pending( String name, Object type )
    {
         // name will only be marked pending if it has not already been
         // parsed before and if is not already pending
         String use = ScopedName.unPseudoName (name);

         if( ! ( pending_interfaces.containsKey(use) ||
                 NameTable.parsed_interfaces.containsKey(use)) )
         {
                 pending_interfaces.put(use, type);
         }
    }

    public static void setGenerator( org.jacorb.idl.IDLTreeVisitor generatorObject )
    {
        generator = generatorObject;
    }

    public static org.jacorb.idl.IDLTreeVisitor getGenerator()
    {
        return generator;
    }

    public static void setObjectCachePlugin(String pluginClass)
        throws InstantiationException, IllegalAccessException
    {
        final Class cachePluginClass;

        try
        {
            if (Thread.currentThread().getContextClassLoader() == null)
            {
                cachePluginClass = Class.forName(pluginClass);
            }
            else
            {
                cachePluginClass = Thread.currentThread().getContextClassLoader().loadClass(pluginClass);
            }
        }
        catch( ClassNotFoundException cnfe )
        {
            throw new ParseException("CachePlugin Class " + pluginClass + " not found! Check classpath!");
        }

        if( ! ObjectCachePlugin.class.isAssignableFrom( cachePluginClass ))
        {
            throw new ParseException( "Not a valid cache plugin: " + pluginClass );
        }

        objectCachePlugin = (ObjectCachePlugin) cachePluginClass.newInstance();
    }

    public static void setObjectCachePlugin(ObjectCachePlugin plugin)
    {
        objectCachePlugin = plugin;
    }

    public static ObjectCachePlugin getObjectCachePlugin()
    {
        return objectCachePlugin;
    }

    public static boolean hasObjectCachePlugin()
    {
        return objectCachePlugin != null;
    }

    public static synchronized void remove_pending( String name )
    {
         String use = ScopedName.unPseudoName (name);
         Object o = pending_interfaces.remove(use);
         if( o != null)
         {
             synchronized( o )
             {
                  o.notifyAll();
             }
         }
         if( pending_interfaces.size() == 0 )
         {
             // notify the main thread that the parsing phase is complete
             synchronized( pending_interfaces )
             {
                  pending_interfaces.notifyAll();
             }
         }
    }

    public static Object get_pending( String name )
    {
        return pending_interfaces.get (ScopedName.unPseudoName (name));
    }

    public static synchronized void decActiveParseThreads()
    {
        activeParseThreads--;
    }

    public static synchronized void incActiveParseThreads()
    {
        activeParseThreads++;
    }

    public static synchronized int activeParseThreads()
    {
        return activeParseThreads;
    }

    public static boolean generateIncluded()
    {
        return generateIncluded;
    }

    public static boolean getInhibitionState()
    {
        return inhibitionState;
    }

    public static void setInhibitionState(boolean flag)
    {
        inhibitionState = flag;
    }

    public static void set_included( boolean i )
    {
        include_state = i;
    }

    public static String getFinalString()
    {
        return finalString;
    }

    public static void setFinalString(String finalString)
    {
        parser.finalString = finalString;
    }

    public static void setGenerateFinalCode(boolean isFinal)
    {
        if (isFinal)
        {
            setFinalString(FINAL);
        }
        else
        {
            setFinalString(NO_FINAL);
        }
    }



    /**
     * Package replacements as requested
     * by compiler options
     */

    public static String pack_replace(String old)
    {
        String n_str = (String)pack_replace.get(old);
        if( n_str == null )
            return old;
        else
            return n_str;
    }

    /**
     * convenience access to the preconfigured loger for the
     * IDL compiler
     */

    public static final Logger getLogger()
    {
        return logger;
    }



:};

/*----------------------------------------------------------------*/

init with
{:
        lexer.init();
:};


scan with
{:
        return lexer.next_token();
:};

/*----------------------------------------------------------------*/

/** terminal symbols and reserved words in IDL:
 *
 * "Object" is listed as reserved in the OMG spec.
 */

terminal org.jacorb.idl.runtime.token
  ABSTRACT, ANY, ATTRIBUTE, BOOLEAN, CASE, CHAR, CONST, CONTEXT, CUSTOM,
  DEFAULT, DOUBLE, ENUM, EXCEPTION, FACTORY, FALSE, FIXED, FLOAT, GETRAISES,
  IN, INOUT, INTERFACE, LOCAL, LONG, MODULE, NATIVE, OBJECT, OCTET, ONEWAY, OUT,
  PRIVATE, PUBLIC, PSEUDO, RAISES, READONLY, SETRAISES, SEQUENCE, SHORT, STRING,
  STRUCT, SUPPORTS, SWITCH, TRUE, TRUNCATABLE, TYPEDEF, TYPEPREFIX, UNSIGNED, UNION,
  VALUEBASE, VALUETYPE, VOID, WCHAR, WSTRING,
  SEMI, COMMA, STAR, DOT, COLON, EQUALS, PLUS, MINUS, LPAREN, RPAREN,
  LCBRACE, RCBRACE, LSBRACE, RSBRACE, LESSTHAN, GREATERTHAN, QUOTE, DBLQUOTE,
  BSLASH, BAR, CIRCUM, AMPERSAND, SLASH, PERCENT, TILDE, DBLCOLON,
  RSHIFT, LSHIFT, LDBLQUOTE, SPACE;


terminal org.jacorb.idl.str_token ID;

/**
 * "int" is not actually a reserved word in IDL, it has been put here
 * merely to prevent its usage as an integer type.
 */

terminal org.jacorb.idl.runtime.char_token CH;
terminal org.jacorb.idl.runtime.int_token  NUMBER;
terminal org.jacorb.idl.runtime.long_token LONG_NUMBER;
terminal org.jacorb.idl.runtime.float_token  FLOAT_NUMBER;
terminal fixed_token  FIXED_NUMBER;

non terminal org.jacorb.idl.runtime.symbol context_expr, string_literal_list;

non terminal org.jacorb.idl.runtime.symbol empty;

non terminal org.jacorb.idl.runtime.int_token op_attribute;
non terminal org.jacorb.idl.runtime.int_token param_attribute;
non terminal org.jacorb.idl.runtime.str_token unary_op;

non terminal Spec specification;
non terminal Definition definition;
non terminal Definitions definitions;
non terminal Module module;
non terminal TypePrefixDecl type_prefix_decl;
non terminal Interface interface;
non terminal InterfaceBody interface_body;
non terminal Definition export;
non terminal ScopedName scopename;
non terminal Truncatable truncatable;

non terminal Value        value;
non terminal ValueBoxDecl value_box_dcl;
non terminal ValueDecl    value_dcl;
non terminal ValueAbsDecl value_abs_dcl;
non terminal ValueBody    value_body;
non terminal ValueInheritanceSpec   value_inheritance_spec;
non terminal Definitions  value_elements;
non terminal Definition   value_element;
non terminal StateMember  state_member;
non terminal InitDecl     init_dcl;
non terminal InitParamDecl init_param_decl;

non terminal ConstDecl const_dcl;
non terminal ConstType const_type;
non terminal ConstExpr const_expr;
non terminal PosIntConst positive_int_const;
non terminal OrExpr or_expr;
non terminal XorExpr xor_expr;
non terminal AndExpr and_expr;
non terminal ShiftExpr shift_expr;
non terminal AddExpr add_expr;
non terminal MultExpr mult_expr;
non terminal UnaryExpr unary_expr;
non terminal PrimaryExpr primary_expr;

non terminal TypeDeclaration type_dcl;
non terminal TypeDeclarator type_declarator;
non terminal TypeSpec type_spec, op_type_spec, param_type_spec,switch_type_spec;
non terminal TypeDef type_def;
non terminal SimpleTypeSpec simple_type_spec;
non terminal TemplateTypeSpec template_type_spec;
non terminal ConstrTypeSpec constr_type_spec;
non terminal EnumType enum_type;
non terminal StructType struct_type, except_dcl;
non terminal UnionType union_type;
non terminal NativeType native_type;
non terminal SwitchBody switch_body;
non terminal Case case;
non terminal ElementSpec element_spec;
non terminal BaseType base_type_spec;
non terminal IntType int_type;
non terminal FloatPtType float_pt_type;
non terminal FloatType float_type;
non terminal FixedPointConstType fixed_pt_const_type;
non terminal DoubleType double_type;
non terminal ShortType short_type;
non terminal LongType long_type;
non terminal LongLongType long_long_type;
non terminal CharType char_type;
non terminal BooleanType bool_type;
non terminal OctetType octet_type;
non terminal AnyType any_type;
non terminal VoidTypeSpec void_type_spec;
non terminal StringType string_type;
non terminal SequenceType sequence_type;
non terminal FixedPointType fixed_point_type;
non terminal Literal literal, string_literal;

non terminal Member member;
non terminal Declarator declarator;
non terminal SimpleDeclarator simple_declarator;
non terminal ArrayDeclarator array_declarator;
non terminal FixedArraySize fixed_array_size;
non terminal ParamDecl param_dcl;
non terminal RaisesExpr raises_expr;
non terminal RaisesExpr raises_expr_nonempty;
non terminal OpDecl op_dcl;
non terminal AttrDecl attr_dcl;
non terminal AttrRaisesExpr attr_raises_expr;

non terminal MemberList member_list;

non terminal SymbolList case_label_list, param_dcls, init_param_decls, parameter_dcls, scopename_list;
non terminal SymbolList simple_declarator_list, declarators;
non terminal SymbolList inheritance_spec, enumerator_list, fixed_array_size_list;

/*----------------------------------------------------------------*/

start with specification;

// #1
specification ::=
        {:
        :}
          definitions:ds
          {:
                /* parsing */

                RESULT.definitions = (Vector)ds.v.clone();

                if( parser.package_prefix != null )
                        RESULT.setPackage( parser.package_prefix );

                RESULT.parse();

                if ( lexer.error_count != 0 )
                {
                    lexer.emit_error( lexer.error_count + " error(s).");
                    throw new ParseException ("Lexer errors");
                }

                // if there are still interfaces to be parsed, wait until the
                // threads performing this have finished. The last one
                // will call notify() :)

                if( parser.pending_interfaces.size() > 0  )
                {
                   // only block waiting if we know that there are active or
                   // runnable threads and that there are still pending tasks
                    final long timeout = 60000;
                    long waitUntil = System.currentTimeMillis() + 20000;

                    synchronized(parser.pending_interfaces)
                    {
                        while(parser.activeParseThreads() > 0 && parser.pending_interfaces.size() > 0 && System.currentTimeMillis() < waitUntil)
                        {
                            parser.pending_interfaces.wait(timeout);
                        }
                    }
                }

                if( parser.pending_interfaces.size() > 0 &&
                    !parser.sloppy )
                {
                    parser.fatal_error("Undefined interface: " +
                        (String)(parser.pending_interfaces.keys().nextElement()), null );
                }


                /* okay, parsing is done */
                parser.done_parsing = true;

                /* code generation phase */

                if (! parser.parse_only  )
                {
                     if( parser.getGenerator() != null )
                     {
                         if (parser.addbackend)
                         {
                             // before the custom backend first use
                             // the default code generator for the Java Mapping
                              RESULT.print( new java.io.PrintWriter( java.lang.System.out ) );
                         }

                          // a custom backend was provided , so let's start
                          // the visitor
                          RESULT.accept( parser.getGenerator() );
                     }
                     else
                     {
                          // use the default code generator for the Java Mapping
                          RESULT.print( new java.io.PrintWriter( java.lang.System.out ) );
                     }
                }

        :}
        | empty
        ;

// #1a

definitions ::=
          definition:d definitions:ds
                {:
                        RESULT.v = (Vector)ds.v.clone();
                        RESULT.v.insertElementAt(d,0);
                :}
        | definition:d
                {:
                        RESULT.v.insertElementAt(d,0);
                :}

        ;

// #2
definition ::=
          type_dcl:t SEMI
                {:
                        RESULT.set_declaration(t);
                :}
        | const_dcl:c SEMI
                {:
                        RESULT.set_declaration(c);
                :}
        | except_dcl:e SEMI
                {:
                        RESULT.set_declaration(e);
                :}
        | interface:p SEMI
                {:
                        RESULT.set_declaration(p);
                :}
        | module:m SEMI
                {:
                        RESULT.set_declaration(m);
                :}
        | type_prefix_decl:pt SEMI
                {:
                        RESULT.set_declaration(pt);
                :}
        | value:m SEMI
                {:
                        RESULT.set_declaration(m);
                :}
        ;

// #3
module ::=
        MODULE ID:i LCBRACE definitions:d RCBRACE
        {:
                RESULT.spec = d;
                RESULT.set_token(i);
                RESULT.setPackage(i.str_val );
                RESULT.set_included( parser.include_state );

                d.setEnclosingSymbol(RESULT);
                parser.closeScope( (Scope)RESULT );
        :}
        ;

type_prefix_decl ::=
        TYPEPREFIX scopename:m DBLQUOTE ID:p DBLQUOTE
        {:
                        RESULT.scopedname = m;
                        RESULT.prefix = p.str_val;
        :}
        ;

// #4,5,6,7
interface ::=
          INTERFACE ID:i inheritance_spec:is LCBRACE interface_body:b RCBRACE
         {:
                RESULT.set_token(i);
                RESULT.inheritanceSpec = is;
                RESULT.body = b ;
                b.set_name(i.str_val);
                b.my_interface = RESULT;
                b.setEnclosingSymbol(RESULT);
                RESULT.set_included( parser.include_state );
                parser.closeScope( (Scope)RESULT );
         :}
         | ABSTRACT INTERFACE ID:i inheritance_spec:is LCBRACE interface_body:b RCBRACE
          {:
                RESULT.set_token(i);
                RESULT.set_abstract();
                RESULT.inheritanceSpec = is;
                RESULT.body = b ;
                b.set_name(i.str_val);
                b.my_interface = RESULT;
                b.setEnclosingSymbol(RESULT);
                RESULT.set_included( parser.include_state );
                parser.closeScope( (Scope)RESULT );
         :}
         | LOCAL INTERFACE ID:i inheritance_spec:is LCBRACE interface_body:b RCBRACE
          {:
                RESULT.set_token(i);
                RESULT.inheritanceSpec = is;
                RESULT.body = b ;
                b.set_name(i.str_val);
                b.my_interface = RESULT;
                b.setEnclosingSymbol(RESULT);
                RESULT.set_included( parser.include_state );
                RESULT.set_locality( true );
                parser.closeScope( (Scope)RESULT );
         :}
        | PSEUDO INTERFACE ID:i inheritance_spec:is LCBRACE interface_body:b RCBRACE
          {:
                RESULT.set_pseudo();
                RESULT.set_token(i);
                RESULT.inheritanceSpec = is;
                RESULT.body = b;
                b.set_pseudo();
                b.set_name(i.str_val);
                b.my_interface = RESULT;
                b.setEnclosingSymbol(RESULT);
                RESULT.set_included( parser.include_state );
                parser.closeScope( (Scope)RESULT );
         :}
        | INTERFACE ID:i
          {:
                RESULT.set_token(i);
                parser.closeScope( (Scope)RESULT );
          :}
        | ABSTRACT INTERFACE ID:i
          {:
                RESULT.set_token(i);
                RESULT.set_abstract();
                parser.closeScope( (Scope)RESULT );
          :}
        | LOCAL INTERFACE ID:i
          {:
                RESULT.set_token(i);
                RESULT.set_locality( true );
                parser.closeScope( (Scope)RESULT );
          :}
        | PSEUDO INTERFACE ID:i
          {:
                RESULT.set_pseudo();
                RESULT.set_token(i);
                parser.closeScope( (Scope)RESULT );
          :}
        ;


// # 8
//      multiple interface_bodies allowed to realize export*

interface_body ::=
          export:e interface_body:i
                {:
                        RESULT.v = (Vector)i.v.clone();
                        RESULT.v.insertElementAt(e,0);
                :}
        | empty
                {: RESULT.commit(); :}
                // so that the i_body knows its vector is complete
        ;

// # 9
export ::=
          type_dcl:t SEMI
                {: RESULT.set_declaration(t); :}
        | const_dcl:c SEMI
                {: RESULT.set_declaration(c); :}
        | except_dcl:e SEMI
                {: RESULT.set_declaration(e); :}
        | attr_dcl:a SEMI
                {: RESULT.set_declaration(a); :}
        | op_dcl:o SEMI
                {: RESULT.set_declaration(o); :}
        ;


// # 10
inheritance_spec ::=
          COLON scopename_list:sl
                {:
                        RESULT.v = (Vector)sl.v.clone();
                :}
        | COLON
                {:
                        lexer.emit_warn("Illegal IDL: empty inheritance spec after colon!");
                :}
        | empty
        ;


scopename_list ::=
          scopename:sn COMMA scopename_list:snl
            {:
                RESULT.v = (Vector)snl.v.clone();
                RESULT.v.insertElementAt(sn,0);
            :}
        | scopename:sn {: RESULT.v.insertElementAt(sn,0); :}
        ;


scopename ::=
          ID:i
                {:
                        RESULT.setId( i.str_val );
                        RESULT.set_token(i);
                :}
        | DBLCOLON ID:i
                {:
                        RESULT.setId( "." + i.str_val);
                        RESULT.set_token(i);
                :}
        | scopename:sn DBLCOLON ID:i
                {:
                        RESULT.setId( sn.typeName+ "." + i.str_val );
                        RESULT.set_token(i);
                 :}
        // not in the IDL grammar, but apparently necessary:
        |  OBJECT:o
                {:
                        RESULT.typeName = "org.omg.CORBA.Object";
                :}
        ;

value ::=
          value_dcl:vd
               {:
                        RESULT.setValue (vd);
                :}
        | value_abs_dcl:vad
               {:
                        RESULT.setValue (vad);
                :}
        | value_box_dcl:vbx
               {:
                        RESULT.setValue (vbx);
                :}
        ;


value_box_dcl ::=
        VALUETYPE ID:i type_spec:ts
                {:
                        RESULT.name = i.str_val;
                        RESULT.typeSpec = ts;
                        RESULT.set_token(i);
                :}
        ;

value_abs_dcl ::=
          ABSTRACT VALUETYPE ID:i value_inheritance_spec:is LCBRACE value_body:b RCBRACE
                {:
                        RESULT.name = i.str_val;
                        RESULT.setInheritanceSpec( is );
                        RESULT.body = b;
                        b.set_name(i.str_val);
                        b.myAbsValue = RESULT;
                        b.setEnclosingSymbol(RESULT);
                        RESULT.set_token (i);
                :}
        | ABSTRACT VALUETYPE ID:i
                {:
                        RESULT.name = i.str_val;
                        RESULT.set_token (i);
                :}
        ;


value_body ::=
          export:e value_body:vb
                {:
                        RESULT.v = (Vector)vb.v.clone();
                        RESULT.v.insertElementAt(e,0);
                :}
          | empty
                {: RESULT.commit(); :}
                // so that the i_body knows its vector is complete
        ;


value_dcl ::=
          CUSTOM VALUETYPE ID:i value_inheritance_spec:is LCBRACE value_elements:ve RCBRACE
                {:
                        RESULT.name = i.str_val;
                        RESULT.set_token (i);
                        RESULT.setInheritanceSpec (is);
                        RESULT.setValueElements (ve);
                        RESULT.isCustomMarshalled (true);
                :}
        | VALUETYPE ID:i
                {:
                        RESULT.name = i.str_val;
                        RESULT.set_token (i);
                        RESULT.isCustomMarshalled (false);
                :}
        | VALUETYPE ID:i value_inheritance_spec:is LCBRACE value_elements:ve RCBRACE
                {:
                        RESULT.name = i.str_val;
                        RESULT.set_token (i);
                        RESULT.setInheritanceSpec (is);
                        RESULT.setValueElements (ve);
                        RESULT.isCustomMarshalled (false);
                :}
       ;

value_inheritance_spec ::=
          COLON truncatable:t scopename_list:vn
                {:
                        RESULT.truncatable = t;
                        RESULT.truncatable.scopedName = (ScopedName)vn.v.remove(0);
                        RESULT.v = (Vector)vn.v.clone();
                :}
        | COLON scopename_list:vn
                {:
                        RESULT.v = (Vector)vn.v.clone();
                :}
        | SUPPORTS scopename_list:interface_names
                {:
                        RESULT.supports = (Vector)interface_names.v.clone();
                :}
        | COLON truncatable:t scopename_list:vn SUPPORTS scopename_list:interface_names
                {:
                        RESULT.truncatable = t;
                        RESULT.truncatable.scopedName = (ScopedName)vn.v.remove(0);
                        RESULT.v = (Vector)vn.v.clone();
                        RESULT.supports = (Vector)interface_names.v.clone();
                :}
        | COLON scopename_list:vn SUPPORTS scopename_list:interface_names
                {:
                        RESULT.v = (Vector)vn.v.clone();
                        RESULT.supports = (Vector)interface_names.v.clone();
                :}
        | COLON
                {:
                        lexer.emit_warn("Illegal IDL: empty inheritance spec after colon!");
                :}
        | empty
        ;

truncatable ::= TRUNCATABLE
        ;

value_elements ::=
          value_element:e value_elements:es
                {:
                        RESULT.v = (Vector)es.v.clone();
                        RESULT.v.insertElementAt(e,0);
                :}
        | empty
        ;

value_element ::=
          export:e
                {:
                        RESULT.set_declaration (e.get_declaration());
                :}
        | state_member:sm
                {:
                        RESULT.set_declaration (sm);
                :}
        | init_dcl:id
                {:
                        RESULT.set_declaration (id);
                :}
        ;


state_member ::=
          PUBLIC type_spec:ts declarators:ds SEMI
                  {:
                           RESULT.isPublic    = true;
                           RESULT.type_spec   = ts;
                           RESULT.declarators = ds;
                  :}

        | PRIVATE type_spec:ts declarators:ds SEMI
                  {:
                           RESULT.isPublic    = false;
                           RESULT.type_spec   = ts;
                           RESULT.declarators = ds;
                  :}
        ;

init_dcl ::=
          FACTORY ID:i LPAREN init_param_decls:ipd RPAREN raises_expr:re SEMI
                {:
                        RESULT.name = i.str_val;
                        RESULT.paramDecls = (Vector)ipd.v.clone();
                        RESULT.raisesExpr = re;
                :}
        | FACTORY ID:i LPAREN RPAREN raises_expr:re SEMI
                {:
                        RESULT.name = i.str_val;
                        RESULT.raisesExpr = re;
                :}
        ;

init_param_decls ::=
          init_param_decl:ip
                {:
                        RESULT.v.insertElementAt( ip, 0);
                :}
        | init_param_decl:ip COMMA init_param_decls:ipdcls
                {:
                        RESULT.v = (Vector)ipdcls.v.clone();
                        RESULT.v.insertElementAt( ip, 0);
                :}
        ;


init_param_decl ::=
          IN param_type_spec:ts simple_declarator:sd
                  {:
                        RESULT.paramTypeSpec = ts;
                        RESULT.simple_declarator = sd;
                  :}
        ;

// #12
const_dcl ::=
         CONST const_type:ct ID:i EQUALS const_expr:ce
                {:
                        RESULT.set_name(i.str_val);
                        RESULT.set_token(i);
                        RESULT.const_expr = ce;
                        RESULT.const_type = (ConstType)ct;
                        RESULT.set_included( parser.include_state );
                :}
        ;

// #13
const_type ::=
          int_type:s {: RESULT.symbol = s; :}
        | char_type:s {: RESULT.symbol = s; :}
        | bool_type:s {: RESULT.symbol = s; :}
        | float_pt_type:s {: RESULT.symbol = s; :}
        | fixed_pt_const_type:s {: RESULT.symbol = s; :}
        | string_type:s {: RESULT.symbol = s; :}
        | octet_type:s {: RESULT.symbol = s; :}
        | scopename:s
                {:
                        RESULT.symbol = s;
                        RESULT.set_token(s.get_token());
                :}
        ;

// #14
const_expr ::= or_expr:o
                {:
                        RESULT.or_expr = o;
                :}
        ;

// #15
or_expr ::=
          xor_expr:x
                {:
                        RESULT.xor_expr = x;
                :}
        | or_expr:o BAR xor_expr:x
                {:
                        RESULT.or_expr = o;
                        RESULT.xor_expr = x;
                :}
        ;

// #16
xor_expr ::=
          and_expr:a
                {:
                        RESULT.and_expr = a;
                :}
        | xor_expr:x CIRCUM and_expr:a
                {:
                        RESULT.and_expr = a;
                        RESULT.xor_expr = x;
                :}
        ;

// #17
and_expr ::=
          shift_expr:s
                {:
                        RESULT.shift_expr = s;
                :}
        | and_expr:a AMPERSAND shift_expr:s
                {:
                        RESULT.and_expr = a;
                        RESULT.shift_expr = s;
                :}
        ;

// #18
shift_expr ::=
          add_expr:a
                {:
                        RESULT.add_expr = a;
                :}
        | shift_expr:s LSHIFT add_expr:a
                {:
                        RESULT.add_expr = a;
                        RESULT.shift_expr = s;
                        RESULT.operator = "<<";
                :}
        | shift_expr:s RSHIFT add_expr:a
                {:
                        RESULT.add_expr = a;
                        RESULT.shift_expr = s;
                        RESULT.operator = ">>";
                :}
        ;


// #19
add_expr ::=
          mult_expr:m
                {:
                        RESULT.mult_expr = m;
                :}
        | add_expr:a PLUS mult_expr:m
                {:
                        RESULT.add_expr = a;
                        RESULT.mult_expr = m;
                        RESULT.operator = "+";
                :}
        | add_expr:a MINUS mult_expr:m
                {:
                        RESULT.add_expr = a;
                        RESULT.mult_expr = m;
                        RESULT.operator = "-";
                :}
        ;

//#20
mult_expr ::=
          unary_expr:u {: RESULT.unary_expr = u; :}
        | mult_expr:m STAR unary_expr:u
                {:
                        RESULT.unary_expr = u;
                        RESULT.mult_expr = m;
                        RESULT.operator = "*";
                :}
        | mult_expr:m SLASH unary_expr:u
                {:
                        RESULT.unary_expr = u;
                        RESULT.mult_expr = m;
                        RESULT.operator = "/";
                :}
        | mult_expr:m PERCENT unary_expr:u
                {:
                        RESULT.unary_expr = u;
                        RESULT.mult_expr = m;
                        RESULT.operator = "%";
                :}
        ;

// #21
unary_expr ::=
          unary_op:u primary_expr:p
                {:
                        RESULT.primary_expr = p;
                        RESULT.unary_op = u.str_val;
                :}
        | primary_expr:p {: RESULT.primary_expr = p; :}
        ;

// #22
unary_op ::=
          MINUS {: RESULT.str_val = "-"; :}
        | PLUS {: RESULT.str_val = "+"; :}
        | TILDE {: RESULT.str_val = "~"; :}
        ;

// #23
primary_expr ::=
          scopename:s {: RESULT.symbol = s; :}
        | literal:l {: RESULT.symbol = l; :}
        | LPAREN const_expr:c RPAREN {: RESULT.symbol = c; :}
        ;


// #24 + 25
literal ::=
          NUMBER:n
                {:
                        RESULT.string = "" + n.int_val;
                        RESULT.primitiveToken = n;
                :}
        | LONG_NUMBER:l
                {:
                        RESULT.string = "" + l.long_val;
                        RESULT.primitiveToken = l;
                :}
        | QUOTE CH:c QUOTE
                {:
                        RESULT.string = "\'" + c.char_val + "\'";
                        RESULT.primitiveToken = c;
                :}
        | string_literal:s
                {:
                        RESULT.string = s.string;
                        RESULT.wide = s.wide;
                :}
        | FIXED_NUMBER:f
                {:
                        RESULT.string = "" + f.fixed_val;
                        RESULT.primitiveToken = f;
                :}
        | FLOAT_NUMBER:n
                {:
                        RESULT.string = "" + n.float_val ;
                        RESULT.primitiveToken = n;
                :}
        | TRUE
                {:
                        RESULT.string = "true";
                :}
        | FALSE
                {:
                        RESULT.string = "false";
                :}
        ;

string_literal ::=
        DBLQUOTE ID:i DBLQUOTE
                 {: RESULT.string = "\"" + i.str_val + "\""; :}
        | DBLQUOTE ID:i DBLQUOTE DBLQUOTE ID:j DBLQUOTE
                 {: RESULT.string = "\"" + i.str_val + j.str_val + "\""; :}
        | DBLQUOTE DBLQUOTE
                 {: RESULT.string = "\"\""; :}
        | LDBLQUOTE ID:i DBLQUOTE
                 {:
                        RESULT.string = "\"" + i.str_val + "\"";
                        RESULT.wide = true;
                 :}
        | LDBLQUOTE ID:i DBLQUOTE LDBLQUOTE ID:j DBLQUOTE
                 {:
                        RESULT.string = "\"" + i.str_val + j.str_val + "\"";
                        RESULT.wide = true;
                 :}
        | LDBLQUOTE DBLQUOTE
                 {:
                        RESULT.string = "\"\"";
                        RESULT.wide = true;
                 :}
        ;

// #26
positive_int_const ::= const_expr:c
                {: RESULT.setExpression( c ); :}
        ;


// #27
type_dcl ::=
          type_def:t
                {: RESULT.type_decl = t; :}
        | struct_type:s
                {: RESULT.type_decl = s; :}
        | union_type:u
                {: RESULT.type_decl = u; :}
        | enum_type:e
                {: RESULT.type_decl = e; :}
        | native_type:n
                {: RESULT.type_decl = n; :}
        ;

type_def ::=
        TYPEDEF type_declarator:t
        {:
                RESULT.type_declarator = t;
                RESULT.set_included( parser.include_state );
        :}
        ;

// #28
type_declarator ::=
        type_spec:ts declarators:ds
                {:
                        RESULT.type_spec = ts;
                        RESULT.declarators = ds;
                :}
        ;

// #29
type_spec ::=
          simple_type_spec:s
                {:
                        RESULT.type_spec = s;
                        RESULT.set_token(s.get_token());
                :}
        | constr_type_spec:s
                {:
                        RESULT.type_spec = s;
                        RESULT.set_token(s.get_token());
                :}
        ;

// #30
simple_type_spec ::=
          base_type_spec:s
                {:
                        RESULT.type_spec = s;
                :}
        | template_type_spec:s
                {:
                        RESULT.type_spec = s;
                        RESULT.set_token(s.get_token());
                :}
        | scopename:s
                {:
                        RESULT.type_spec = s;
                        RESULT.set_token(s.get_token());
                :}
        ;

// #31
base_type_spec ::=
          float_pt_type:s {: RESULT.type_spec = s; :}
        | int_type:s
                {:
                        RESULT.type_spec = s;
                :}
        | char_type:s {: RESULT.type_spec = s; :}
        | bool_type:s {: RESULT.type_spec = s; :}
        | octet_type:s {: RESULT.type_spec = s; :}
        | any_type:s {: RESULT.type_spec = s; :}
        | VALUEBASE:s {: RESULT.type_spec = new ValueBase(sym.VALUEBASE); :}
        ;

// #32
template_type_spec ::=
          sequence_type:s
                {:
                        RESULT.type_spec = s;
                        RESULT.set_token(s.get_token());
                :}
        | string_type:s
                {:
                        RESULT.type_spec = s;
                        RESULT.set_token(s.get_token());
                :}
        | fixed_point_type:f
                {:
                        RESULT.type_spec = f;
                        RESULT.set_token(f.get_token());
                :}
        ;

// #33
constr_type_spec ::=
          struct_type:s
                {:
                        RESULT.c_type_spec = s;
                        RESULT.set_token(s.get_token());
                :}
        | union_type:u
                {:
                        RESULT.c_type_spec = u;
                        RESULT.set_token(u.get_token());
                :}
        | enum_type:e
                {:
                        RESULT.c_type_spec = e;
                        RESULT.set_token(e.get_token());
                :}
        ;

// #34
declarators ::=
          declarator:d COMMA declarators:ds
                {:
                        RESULT.v = (Vector)ds.v.clone();
                        RESULT.v.insertElementAt(d,0);
                :}
        | declarator:d
                {:
                        RESULT.v.insertElementAt(d,0);
                 :}
        ;

// #35 + 37
declarator ::=
          simple_declarator:s
                {: RESULT.d = s; :}
        | array_declarator:s
                {: RESULT.d = s; :}
        ;

// #36
simple_declarator ::= ID:i
                {:
                        RESULT.set_token(i);
                :}
        ;

// #38
float_pt_type ::=
          float_type:f
                {:RESULT.type_spec = f; :}
        | double_type:d
                {: RESULT.type_spec = d;
                 :}
        ;

float_type ::=
          FLOAT
        ;

fixed_pt_const_type ::=
        FIXED
        ;

//
double_type ::=
          DOUBLE
        | LONG DOUBLE
          {:
                RESULT.setLongDouble();
                lexer.emit_warn("IDL type long double not supported by standard IDL/Java mappings!");
          :}
        ;

// #39-45
int_type ::=
          long_type:l
                {:
                        RESULT.type_spec = l;
                :}
        | long_long_type:ll
                {:
                        RESULT.type_spec = ll;
                :}
        | UNSIGNED long_type:l
                {:
                        RESULT.type_spec = l;
                        RESULT.setUnsigned();
                :}
        | UNSIGNED long_long_type:l
                {:
                        RESULT.type_spec = l;
                        RESULT.setUnsigned();
                :}
        | short_type:s
                {:
                        RESULT.type_spec = s;
                :}
        | UNSIGNED short_type:s
                {:
                        RESULT.type_spec = s;
                        RESULT.setUnsigned();
                :}
        ;

short_type ::=
        SHORT
        ;

long_type ::=
        LONG
        ;

long_long_type ::=
        LONG LONG
        ;

// #46
char_type ::=
          CHAR
        | WCHAR
        {: RESULT.setWide(); :}
        ;

// #47
bool_type ::=
        BOOLEAN
        ;

// #48
octet_type ::=
        OCTET
        ;

// #49
any_type ::=
        ANY
        ;

// #50
struct_type ::=
        STRUCT ID:i LCBRACE member_list:ml RCBRACE
                {:
                        RESULT.set_token(i);
                        RESULT.exc = false;
                        RESULT.set_memberlist( ml );
                        RESULT.set_included( parser.include_state );
                        parser.closeScope( (Scope)RESULT );
                :}
        | STRUCT ID:i
                {:
                        RESULT.set_token(i);
                        parser.closeScope( (Scope)RESULT );
               :}
        ;

// #51
member_list ::=
          member:m
                {:
                        RESULT.v.insertElementAt(m,0);
                :}
        | member:m member_list:ml
                {:
                        RESULT.v = (Vector)ml.v.clone();
                        RESULT.v.insertElementAt(m,0);
                :}
        ;

// #52
member ::=
        type_spec:ts declarators:ds SEMI
                {:
                        RESULT.type_spec = ts;
                        RESULT.declarators = ds;
                :}
        ;

// #53
union_type ::=
        UNION ID:i SWITCH LPAREN switch_type_spec:s RPAREN
                LCBRACE switch_body:sb RCBRACE
                {:
                        RESULT.setSwitchType( s );
                        RESULT.setSwitchBody( sb );
                        RESULT.set_token(i);
                        RESULT.set_included( parser.include_state );
                        parser.closeScope( (Scope)RESULT );
                :}
        | UNION ID:i
                {:
                        RESULT.set_token(i);
                        parser.closeScope( (Scope)RESULT );
                :}
        ;

// #54
switch_type_spec ::=
          int_type:i {: RESULT.type_spec = i; :}
        | char_type:c {: RESULT.type_spec = c; :}
        | bool_type:b {: RESULT.type_spec = b; :}
        | enum_type:e {: RESULT.set_constr(e); :}
        | scopename:s {: RESULT.type_spec = s; :}
        ;

// #55
switch_body ::=
          case:c
        {:
                RESULT.caseListVector.insertElementAt(c, 0);
        :}
        | case:c switch_body:sb
        {:
                RESULT.caseListVector = (Vector)sb.caseListVector.clone();
                RESULT.caseListVector.insertElementAt(c, 0);
        :}
        ;

// #56
case ::=
        case_label_list:c element_spec:es SEMI
                {:
                        RESULT.element_spec = es;
                        RESULT.case_label_list = c;
                :}
        ;

// #56b)
case_label_list ::=
          CASE const_expr:c COLON
                {: RESULT.v.addElement(c); :}
        | DEFAULT COLON
                {: RESULT.v.addElement( null ); :}
        | CASE const_expr:c COLON case_label_list:cll
                {:
                        RESULT.v = (Vector)cll.v.clone();
                        RESULT.v.addElement(c);
                :}
        | DEFAULT COLON case_label_list:cll
                {:
                        RESULT.v = (Vector)cll.v.clone();
                        RESULT.v.addElement(null);
                :}
        ;

// #57 (integrated in #56b

// #58
element_spec ::=
        type_spec:ts declarator:dc
                {:
                        RESULT.typeSpec.type_spec = ts;
                        RESULT.declarator = dc;
                :}
        ;

// #59
enum_type ::=
        ENUM ID:i LCBRACE enumerator_list:el RCBRACE
                {:
                        RESULT.set_token(i);
                        RESULT.enumlist = el;
                        RESULT.set_included( parser.include_state );
                :}
        ;

// #60
enumerator_list ::=
          ID:i
                {:
                        RESULT.v.insertElementAt(i.str_val,0);
                        RESULT.set_token(i);
                :}
        | ID:i COMMA enumerator_list:el
                {:
                        RESULT.v = (Vector)el.v.clone();
                        RESULT.v.insertElementAt(i.str_val,0);
                        RESULT.set_token(i);
                :}
        ;


native_type ::=
        NATIVE simple_declarator:sd
                {:
                        RESULT.declarator = sd;
                :}
        ;

// #61
sequence_type ::=
          SEQUENCE LESSTHAN simple_type_spec:sts
                            COMMA positive_int_const:pic GREATERTHAN
                {:
                        RESULT.max = pic.const_expr;
                        RESULT.setTypeSpec( sts );
                :}
        | SEQUENCE LESSTHAN simple_type_spec:sts GREATERTHAN
                {:
                        RESULT.setTypeSpec( sts );
                :}
        ;

// # 62
string_type ::=
          STRING LESSTHAN positive_int_const:pic GREATERTHAN
          {:
               RESULT.setSize(pic.const_expr);
          :}
        | WSTRING LESSTHAN positive_int_const:pic GREATERTHAN
          {:
                RESULT.setSize(pic.const_expr);
                RESULT.setWide();
          :}
        | STRING
        | WSTRING
        {: RESULT.setWide(); :}
        ;

fixed_point_type ::=
          FIXED LESSTHAN positive_int_const:digits COMMA positive_int_const:scale GREATERTHAN
          {:
                RESULT.digit_expr = digits.const_expr;
                RESULT.scale_expr = scale.const_expr;
         :}
        ;



// #63
array_declarator ::=
          ID:i fixed_array_size_list:fasl
                {:
                        RESULT.set_token(i);
                        RESULT.fixed_array_size_list = fasl;
                :}
        ;

fixed_array_size_list ::=
          fixed_array_size:fas
                {:
                        RESULT.v.insertElementAt(fas,0);
                :}
        | fixed_array_size:fas fixed_array_size_list:fasl
                {:
                        RESULT.v = (Vector)fasl.v.clone();
                        RESULT.v.insertElementAt(fas,0);
                :}
        ;

// #64
fixed_array_size ::=
        LSBRACE positive_int_const:pic RSBRACE
                {:
                        RESULT.pos_int_const = pic;
                :}
        ;

attr_dcl ::=
    READONLY ATTRIBUTE param_type_spec:pts simple_declarator_list:sdl
      {:
          RESULT.readOnly = true;
          RESULT.param_type_spec = pts;
          RESULT.declarators = sdl;
          RESULT.getRaisesExpr = new RaisesExpr();
          RESULT.setRaisesExpr = new RaisesExpr();
      :}
  | READONLY ATTRIBUTE param_type_spec:pts simple_declarator:sd
          raises_expr_nonempty:re
      {:
          RESULT.readOnly = true;
          RESULT.param_type_spec = pts;
          RESULT.declarators = new SymbolList (sd);
          RESULT.getRaisesExpr = re;
          RESULT.setRaisesExpr = new RaisesExpr();
      :}
  | ATTRIBUTE param_type_spec:pts simple_declarator_list:sdl
      {:
          RESULT.readOnly = false;
          RESULT.param_type_spec = pts;
          RESULT.declarators = sdl;
          RESULT.getRaisesExpr = new RaisesExpr();
          RESULT.setRaisesExpr = new RaisesExpr();
      :}
  | ATTRIBUTE param_type_spec:pts simple_declarator:sd attr_raises_expr:are
      {:
          RESULT.readOnly = false;
          RESULT.param_type_spec = pts;
          RESULT.declarators = new SymbolList (sd);
          RESULT.getRaisesExpr = new RaisesExpr (are.getNameList);
          RESULT.setRaisesExpr = new RaisesExpr (are.setNameList);
      :}
  ;

attr_raises_expr ::=
         GETRAISES LPAREN scopename_list:get_snl RPAREN
         SETRAISES LPAREN scopename_list:set_snl RPAREN
         {:
            RESULT.getNameList = (Vector)get_snl.v.clone();
            RESULT.setNameList = (Vector)set_snl.v.clone();
         :}
       | SETRAISES LPAREN scopename_list:set_snl RPAREN
         GETRAISES LPAREN scopename_list:get_snl RPAREN
         {:
            RESULT.getNameList = (Vector)get_snl.v.clone();
            RESULT.setNameList = (Vector)set_snl.v.clone();
         :}
       | GETRAISES LPAREN scopename_list:get_snl RPAREN
         {:
            RESULT.getNameList = (Vector)get_snl.v.clone();
         :}
       | SETRAISES LPAREN scopename_list:set_snl RPAREN
         {:
            RESULT.setNameList = (Vector)set_snl.v.clone();
         :}
       ;


simple_declarator_list ::=
          simple_declarator:sd
                {:
                        RESULT.v.insertElementAt(sd,0);
                :}
        | simple_declarator:sd COMMA simple_declarator_list:sdl
                {:
                        RESULT.v = (Vector)sdl.v.clone();
                        RESULT.v.insertElementAt(sd,0);
                :}
        ;

// #66
except_dcl ::=
          EXCEPTION ID:i LCBRACE RCBRACE
                {:
                        RESULT.set_token(i);
                        RESULT.exc = true;
                        RESULT.set_included( parser.include_state );
                        parser.closeScope( (Scope)RESULT );
                :}
        | EXCEPTION ID:i LCBRACE member_list:ml RCBRACE
                {:
                        RESULT.set_token(i);
                        RESULT.exc = true;
                        RESULT.set_memberlist( ml );
                        RESULT.set_included( parser.include_state );
                        parser.closeScope( (Scope)RESULT );
                :}
        ;


// #67
op_dcl ::=
        op_attribute:oa op_type_spec:ots ID:i parameter_dcls:pds
                raises_expr:re context_expr
          {:
                        RESULT.opAttribute = oa.int_val;
                        RESULT.opTypeSpec = ots;
                        RESULT.set_token(i);
                        RESULT.paramDecls = (Vector)pds.v.clone();
                        RESULT.raisesExpr = re;
          :}
        ;

// #68
op_attribute ::=
          ONEWAY
                {: RESULT.int_val = OpDecl.ONEWAY; :}
        | empty
                {: RESULT.int_val = OpDecl.NO_ATTRIBUTE; :}
        ;

// #69
op_type_spec ::=
          param_type_spec:s {: RESULT.type_spec = s; :}
        | void_type_spec:s {: RESULT.type_spec = s; :}
        ;


void_type_spec ::=
        VOID
        ;

// #70
parameter_dcls ::=
          LPAREN param_dcls:pds RPAREN
                {:
                        RESULT.v = (Vector)pds.v.clone();
                :}
        | LPAREN RPAREN
        ;


param_dcls ::=
          param_dcl:pd COMMA param_dcls:pds
            {:
                        RESULT.v = (Vector)pds.v.clone();
                        RESULT.v.insertElementAt(pd,0);
                :}
        | param_dcl:pd
                {:
                        RESULT.v.insertElementAt(pd,0);
                :}
        ;

// #71
param_dcl ::=
        param_attribute:pa param_type_spec:pts simple_declarator:sd
          {:
                RESULT.paramAttribute = pa.int_val;
                RESULT.paramTypeSpec = pts;
                RESULT.simple_declarator = sd;
          :}
        ;

// #72
param_attribute ::=
          IN    {: RESULT.int_val = ParamDecl.MODE_IN; :}
        | OUT   {: RESULT.int_val = ParamDecl.MODE_OUT; :}
        | INOUT {: RESULT.int_val = ParamDecl.MODE_INOUT; :}
        ;

// #73
raises_expr ::=
          RAISES LPAREN scopename_list:snl RPAREN
        {:
                RESULT.nameList = (Vector)snl.v.clone();
        :}
        | empty
        ;

raises_expr_nonempty ::=
          RAISES LPAREN scopename_list:snl RPAREN
        {:
                RESULT.nameList = (Vector)snl.v.clone();
        :}
        ;

// #74
context_expr ::=
          CONTEXT LPAREN string_literal_list RPAREN
        | empty
        ;

string_literal_list ::=
          string_literal
        | string_literal COMMA string_literal_list
        ;

// #75
param_type_spec ::=
          base_type_spec:s {: RESULT.type_spec = s; :}
        | string_type:s {: RESULT.type_spec = s; :}
        | scopename:s {: RESULT.type_spec = s; :}
        ;

empty ::= /* nothing */;
